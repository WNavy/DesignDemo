代理模式：为其他对象提供一种代理用来控制对这个对象的访问，并可以在不改变目标对象的情况下添加一些额外的功能。

特征：代理类和被代理类实现相同接口或继承相同的抽象类。

角色：
抽象对象角色：声明了目标对象和代理对象的共同接口，任何可以使用目标对象的地方都可以使用代理对象
目标对象角色：也叫被委托定义了目标对象
代理对象角色：代理对象内部含有目标对象的引用，可以在任何时候操作目标对象。代理对象提供一个与目标对象相同的接口，
            以便可以在任何时候替代目标对象。

代理模式的实现方式：聚合和继承两种方式

    聚合：定义一个角色接口，代理对象和被代理对象都实现相同的角色接口。
         同时代理对象内部有对被代理对象的引用(推荐使用聚合方式)
    继承：定义一个抽象角色，代理对象和被代理对象都继承相同的抽象角色。

代理模式中的动态代理：

1、JDK代理
特点：
    1、代理对象不需要实现接口，一般为代理工厂
    2、代理对象的生成是利用JDK的API动态的在内存中构件代理对象(需要我们指定创建代理对象/目标对象实现的接口类型)
    3、API使用java.lang.reflect.Proxy中的newProxyInstance方法
    4、目标对象一定要实现接口，否则不能动态代理

  JDK代理主要的API是使用newProxyInstance方法，该方法接收三个参数：
  ClassLoader loader：指定当前目标对象使用类加载器，获取类加载器的方法是固定的obj.getClass().getClassLoader()
  Class<?>[] interfaces：目标对象实现的接口类型
  InvocationHandler h：事件处理，执行目标对象方法时，会触发事件处理器的方法

 静态代理和JDK动态代理，都需要代理对象实现或继承一个抽象角色。

2、Cglib代理

    1、以目标对象子类的方式实现代理。
    2、Cglib包底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类

   实现方法：

   1、引入cglib的jar包，spring的核心包中已经包含了Cglib功能，所以直接引入spring-core的jar包
   2、代理的类不能是final
   3、目标对象的方法如果被final或static修饰，就不会被拦截，即不会执行目标对象额外的扩展方法
   4、实现MethodInterceptor接口

 总结：如果目标对象实现了接口，则使用jdk动态代理，如果没有，则使用Cglib动态代理



